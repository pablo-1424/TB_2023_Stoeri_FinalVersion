## GPIOs features

### GPIO API
The GPIOs API is referenced in it_sdk/wrappers.h and implemented for each of the platform.

### GPIO initial configuration

The GPIO configuration can be done with code generator like CubeMX for STM32 MCU. It is lso possible to use the GPIO function to initialize them manually. The different high level functions are in it_sdk/wrappers.h header and implemented according to the target.

### GPIO state during low power

During Low power mode all the GPIOs are set to analog state to reduce the power consumption. So to keep a GPIO active in the same configuration you need to exclude the GPIOs in the itsdk/config.h file.

```C
#define ITSDK_LOWPOWER_GPIO_A_KEEP	(  __LP_GPIO_1  \
									 | __LP_GPIO_2  \
									 | __LP_GPIO_13	\
									 | __LP_GPIO_14	\
									 | __LP_GPIO_15	\
		                            )
```			 

A define is to be set for each of the GPIO Bank. The list of Pin to be preserved for this Bank is listed as in the previous exemple.

During the Low Power period, the GPIO capable to imediatly wake the system up are listed in the following defines:
```C
#define ITSDK_LOWPOWER_GPIO_A_WAKE (    __LP_GPIO_0  \
									 			| __LP_GPIO_2  
									 		 )
```
There are one define per GPIO bank. Actually this define is not used in the code. That said it is a reminder for the Pin configured as wakeup pin.
It is important to have these pin correctly setup as EXTI for having the correct Interrupt callback affected


### GPIO state after low power wake up

The low power resume function call the ARCHI_lowPowerRestoreGpioConfig() this function is calling back the GPIO_Init function generated by your code generator (at least for STM32). 
This function can be override with you own function to correctly restore the pin setting on wakeup.

### GPIO Interrupt management
To register an interrupt you need to use gpio_registerIrqAction(gpio_irq_chain_t * chain); this function will manage a queue of the different IRQ for each of the pins.
 
```C
typedef struct s_gpio_irq_chain {
	void (*irq_func)(uint16_t GPIO_Pin);
	uint16_t pinMask;
	struct s_gpio_irq_chain * next;
} gpio_irq_chain_t;
```

Then the implementation will manage the routing to the interrupt callback (irq_func). The pinMask allows to have a common callback for mutiple interrupt. 

A Wake-Up specif mechanism is implemented. When an IRQ Wake-UP the MCU the normal IRQ processing is postpowned waiting the MCU to be coorectly reconfigured after waking up. A specific IRQ handler is set thanks to *gpio_registerWakeUpAction(...)* call. Once set this handler and only this one will be called on GPIO Irq. Once the *gpio_removeWakeUpAction()* called the normal IRQ chain will be fired on gpio IRQ.


#### STM32
The Interrupt handler is overriding HAL_GPIO_EXTI_Callback.
 
