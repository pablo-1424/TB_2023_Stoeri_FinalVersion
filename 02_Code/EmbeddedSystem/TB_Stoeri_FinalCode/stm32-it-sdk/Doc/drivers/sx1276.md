# SX1276 / MURATA common 
### Hardware Init Only
* If you do not need the radio stack configured at startup but you want to start powering the device low, you have a dedicated function for this purpose:
```C
#include <drivers/sx1276/sx1276.h>
SX1276InitLowPower();
``` 
This function does not make the radio software stack init but init the different pins, stops the TXCO and switch the semtech chip to low power.

# SX1276 / MURATA used as LoRaWan

## Gpio configuration
- Recommanded gpio init 
* DIO0/1/2/3/(4) as IT_Rising in Cube Mx at least to get the interrupt handler set
* TCXO as Set
  
- You need to keep some gpio signals enabled during low-power switch to ensure it work, you can disable the otherone
```C
#define ITSDK_LOWPOWER_GPIO_A_KEEP	(__LP_GPIO_NONE \
								/*	 | __LP_GPIO_1 */ 	/* LoRa RF sw */\
									 | __LP_GPIO_5 		/* LoRa Dio4 */ \
								/*	 | __LP_GPIO_6 */	/* SPI1 */ \
								/*	 | __LP_GPIO_7 */ 	/* SPI1 */ \
									 | __LP_GPIO_8 		/* LoRa Dio5 */ \
								/*	 | __LP_GPIO_15	*/	/* LoRa Nss */ \
		                            )										// Keep activ 
#define ITSDK_LOWPOWER_GPIO_B_KEEP	(  __LP_GPIO_NONE \
								/*	 | __LP_GPIO_0   */ /* LoRa Dio2 */\
								/*   | __LP_GPIO_1   */ /* LoRa Dio1 */\
								/*	 | __LP_GPIO_2 	 */ /* LoRa TCXO */\
								/*	 | __LP_GPIO_3 	 */ /* SPI1 */ \
								/*	 | __LP_GPIO_4 	 */ /* LoRa Dio0 */\
									)										// Keep activ 
#define ITSDK_LOWPOWER_GPIO_C_KEEP	( __LP_GPIO_NONE \
									  | __LP_GPIO_0 	/* LoRa Reset */\
									  | __LP_GPIO_1 	/* LoRa Tx Boost */\
									  | __LP_GPIO_2 	/* LoRa Radiosw */\
								/*    | __LP_GPIO_13 */ /* LoRa Dio 3 */\

```
- this means you need to restore the configuration of these gpio signal on low-power restart adding the gpio restore function in __gpio.c__ generated by CubeMX with the following minial configuration
```C 
/* USER CODE BEGIN 0 */
#include <it_sdk/config.h>
#include <it_sdk/wrappers.h>
/* USER CODE END 0 */

...
/* USER CODE BEGIN 2 */
void stm32l_lowPowerRestoreGpioConfig() {


	  /* GPIO Ports Clock Enable */
	  __HAL_RCC_GPIOA_CLK_ENABLE();
	  __HAL_RCC_GPIOB_CLK_ENABLE();
	  __HAL_RCC_GPIOC_CLK_ENABLE();
	  __HAL_RCC_GPIOH_CLK_ENABLE();


	  // RF sw
	  gpio_configure_ext(ITSDK_MURATA_ANTSW_RX_BANK,ITSDK_MURATA_ANTSW_RX_PIN,GPIO_OUTPUT_PP,ITSDK_GPIO_SPEED_HIGH,ITSDK_GPIO_ALT_NONE);

	  // LoRa NSS
	  gpio_configure_ext(ITSDK_SX1276_NSS_BANK,ITSDK_SX1276_NSS_PIN,GPIO_OUTPUT_PULLUP,ITSDK_GPIO_SPEED_HIGH,ITSDK_GPIO_ALT_NONE);

	  // LoRa TCXO
	  gpio_configure_ext(ITSDK_SX1276_TCXO_VCC_BANK,ITSDK_SX1276_TCXO_VCC_PIN,GPIO_OUTPUT_PP,ITSDK_GPIO_SPEED_HIGH,ITSDK_GPIO_ALT_NONE);

	  // LoRa DIO0-1-2-3
	  gpio_configure_ext(ITSDK_SX1276_DIO_0_BANK,ITSDK_SX1276_DIO_0_PIN,GPIO_INTERRUPT_RISING,ITSDK_GPIO_SPEED_HIGH,ITSDK_GPIO_ALT_NONE);
	  gpio_configure_ext(ITSDK_SX1276_DIO_1_BANK,ITSDK_SX1276_DIO_1_PIN,GPIO_INTERRUPT_RISING,ITSDK_GPIO_SPEED_HIGH,ITSDK_GPIO_ALT_NONE);
	  gpio_configure_ext(ITSDK_SX1276_DIO_2_BANK,ITSDK_SX1276_DIO_2_PIN,GPIO_INTERRUPT_RISING,ITSDK_GPIO_SPEED_HIGH,ITSDK_GPIO_ALT_NONE);
	  gpio_configure_ext(ITSDK_SX1276_DIO_3_BANK,ITSDK_SX1276_DIO_3_PIN,GPIO_INTERRUPT_RISING,ITSDK_GPIO_SPEED_HIGH,ITSDK_GPIO_ALT_NONE);

	  /* EXTI interrupt init*/
	  HAL_NVIC_SetPriority(EXTI0_1_IRQn, 0, 0);
	  HAL_NVIC_EnableIRQ(EXTI0_1_IRQn);

	  HAL_NVIC_SetPriority(EXTI4_15_IRQn, 0, 0);
	  HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);
}

```



# SX1276 / MURATA used as Sigfox

## Pre-requisites
You need to get the library file from ST devkit and add them in the following order
- SgfxSTModemSx1276V123_CM0_GCC
- SgfxCoreV231_CM0_GCC
- SgfxCmacV100_CM0_GCC
- SgfxAddonV020_CM0_GCC

### Hardware configuration (routing): 
* TCXO powered is controled by a GPIO => This allows to keept it activ as we want
* PH0-OSC connected to TCXO-OUT => This allows to use TCXO as a HSE clock source. The purpose is to have a synchro between the MCU clock and the generated signal during signal transmission over DMA
* DIO4 connected to a GPIO => DIO4 is an interrupt channel for Sigfox mode it needs to be connected 

### Cube Mx configuration
* The SPI pins need to be set including PA15 GPIO_SPEED_FREQ_VERY_HIGH => 32MHz
* PA15 (SPI_NSS)
  * SPI_NSS pin should be configured PULL_UP with Set as initial state
  * Speed is VERY_HIGH
* TIM2 is enable with Internal Clock source / nothing specific it will be setup by the driver code
* SPI1 is enable with
  * Soft NSS
  * SPI_BAUDRATEPRESCALER_32 (it will be reconfigured by the driver code) 
  * Data Size 8b (it will be reconfigured by the driver code)
  * DMA Settings : Enable SPI_TX DMA Request on default channel (it will be reconfigured by the driver code)
  * Enable DMA1 channel2 & 3 interrupt
  * Disable SPI1 global interrupt
  * Set GPIO as Very High Speed
* DIO4 must be declared as Interrupt to have the interrupt handler set for this pin  

### Coding constraint
* You need to call the sigfox processing loop (this is curently a workaround for a bug(?) where the CPU hang when switching from HSI to HSE if not done on regular basis)
```C
void project_loop() {
	...
#if ITSDK_WITH_SIGFOX_LIB	== __ENABLE
	if ( itsdk_config.sdk.activeNetwork == __ACTIV_NETWORK_SIGFOX ) {
	   itsdk_sigfox_loop();
	}
#endif
	...
}
```
